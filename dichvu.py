import logging
import random
import datetime
import asyncio
from typing import Dict, Any
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputMediaPhoto
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes

# ====== C·∫§U H√åNH (THAY TOKEN & ADMINS) ======
TOKEN = "8425555736:AAFMu78_-x_sIKzyDeZu3V1di1W4UESqwvg"
ADMINS = {6251713157}  # <-- thay b·∫±ng Telegram user ID admin (c√≥ th·ªÉ nhi·ªÅu IDs)
ADMIN_TELEGRAM_LINK = "https://t.me/frog024" # Thay @frog024 b·∫±ng username c·ªßa b·∫°n

# ·∫¢nh menu ch√≠nh (banner)
MENU_PHOTO = "https://i.postimg.cc/Y90NyGD7/photo-2025-08-30-10-13-55.jpg"

# Th√¥ng tin thanh to√°n
PAYMENT_INFO_TEXT = (
    "üí≥ TH√îNG TIN THANH TO√ÅN\n\n"
    "‚Ä¢ MoMo: 0862425144 (QUANG VAN TRUONG)\n"
    "‚Ä¢ MB Bank: 08624251 (QUANG VAN TRUONG))\n\n"
    "üëâ Vui l√≤ng ghi ƒë√∫ng M√É GD ƒë√£ cho v√†o ph·∫ßn n·ªói dung chuy·ªÉn kho·∫£n tr∆∞·ªõc khi chuy·ªÉn ti·ªÅn ."
    "l∆∞u √Ω n·∫øu ghi sai m√£ GD ho·∫∑c nh·∫ßm l·∫´n h√£y li√™n h·ªá admin ngay!"
    "sau 30p k·ªÉ t·ª´ l√∫c b·∫°n s√£y ra nh·∫ßm l·∫´n trong hay ghi sai m√£ admin s·∫Ω kh√¥ng h·ªô tr·ª£ ƒë∆∞·ª£c."
    "n·∫øu c√≥ th·∫Øc m·∫Øc g√¨ li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c h·ªô tr·ª£."
)

# Danh s√°ch g√≥i (m√£ => label)
PACKAGES = {
    "15p": "15 ph√∫t ‚Äì 199k",
    "30p": "30 ph√∫t ‚Äì 399k",
    "1h": "1 gi·ªù ‚Äì 799K",
    "3h": "3 gi·ªù ‚Äì 1TR444K",
    "8h": "Nguy√™n ƒë√™m (8h) ‚Äì 1TR999K",
}

# Th·ªùi l∆∞·ª£ng t·ª´ng g√≥i (gi√¢y)
PACKAGE_SECONDS = {
    "15p": 15 * 60,
    "30p": 30 * 60,
    "1h": 60 * 60,
    "3h": 3 * 60 * 60,
    "8h": 8 * 60 * 60,
}

# Danh s√°ch ng∆∞·ªùi (key => d·ªØ li·ªáu)
PEOPLE = {
    "ngocnhi": {
        "name": "üîûüîûü•µYUMI call show c·ª±c m√∫pü•µüîûüîû",
        "desc": "üîûüîûth√¢n thi·ªán - l·ªìn m√∫p c√≤n h·ªìng - n√≥i chuy·ªán vui t√≠nh - hi·ªÉu √Ωüîûüîû",
        "photo": "https://i.postimg.cc/pVB0mmrB/YUMI.jpg",
        "contact": "tele : @TieuKhaAi2005"
    },
    "anhnguyet": {
        "name": "ch∆∞a c√≥ ",
        "desc": "ch∆∞a c√≥",
        "photo": MENU_PHOTO,
        "contact": "ch∆∞a c√≥"
    },
    "minhhuyen": {
        "name": "ch∆∞a c√≥ ",
        "desc": "ch∆∞a c√≥",
        "photo": MENU_PHOTO,
        "contact": "ch∆∞a c√≥"
    },
    "caothi": {
        "name": "ch∆∞a c√≥",
        "desc": "ch∆∞a c√≥",
        "photo": MENU_PHOTO,
        "contact": "ch∆∞a c√≥"
    },
    "ngocanh": {
        "name": "ch∆∞a c√≥",
        "desc": "ch∆∞a c√≥.",
        "photo": MENU_PHOTO,
        "contact": "ch∆∞a c√≥"
    },
}

# ORDERS: l∆∞u c√°c ƒë∆°n t·∫°m, ch·ªù user x√°c nh·∫≠n thanh to√°n
ORDERS: Dict[str, Dict[str, Any]] = {}

# TRANSACTION_HISTORY: l∆∞u c√°c ƒë∆°n ƒë√£ ƒë∆∞·ª£c admin duy·ªát/t·ª´ ch·ªëi
TRANSACTION_HISTORY: Dict[str, Dict[str, Any]] = {}

# SESSIONS t·∫°m user_id -> {package, person, tx}
SESSIONS: Dict[int, Dict[str, Any]] = {}

# ACTIVE_COUNTDOWNS: tx -> {user_id, msg_id, ends_at_ts, contact_text, task}
ACTIVE_COUNTDOWNS: Dict[str, Dict[str, Any]] = {}

# ====== Anti-spam ======
# L∆∞u timestamps c√°c action c·ªßa user ƒë·ªÉ gi·ªõi h·∫°n t·ªëc ƒë·ªô
USER_ACTIONS: Dict[int, list] = {}
# Strike counts, block_until timestamp
USER_STRIKES: Dict[int, Dict[str, Any]] = {}
SPAM_WINDOW = 60  # seconds window
SPAM_MAX_ACTIONS = 12  # max callback presses per window
STRIKE_LIMIT = 3  # sau 3 l·∫ßn vi ph·∫°m -> block 10 min
BLOCK_SECONDS = 10 * 60

# ====== Logging ======
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# ====== Helpers ======
def gen_transaction_id() -> str:
    return "GD" + str(random.randint(100000, 999999))

def is_person_busy(person_key: str) -> bool:
    """Ki·ªÉm tra xem m·ªôt ng∆∞·ªùi c√≥ ƒëang c√≥ phi√™n ho·∫°t ƒë·ªông kh√¥ng."""
    for session in ACTIVE_COUNTDOWNS.values():
        if session.get("person") == person_key:
            return True
    return False

def kb_main_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üîûüîûthu√™ ng∆∞·ªùi call sexüåö / tr√≤ chuy·ªán v·ªÅ ƒë√™müåö üîûüîû", callback_data="menu|packages")],
        # ƒê√£ thay ƒë·ªïi th√†nh callback_data ƒë·ªÉ c√≥ th·ªÉ ki·ªÉm so√°t tr·∫°ng th√°i c·∫•m
        [InlineKeyboardButton("üíå Li√™n h·ªá Admin", callback_data="menu|contact_admin")]
    ])

def kb_packages():
    rows = [[InlineKeyboardButton(label, callback_data=f"packages|{code}")] for code, label in PACKAGES.items()]
    rows.append([InlineKeyboardButton("‚¨ÖÔ∏è Quay l·∫°i", callback_data="back|main")])
    return InlineKeyboardMarkup(rows)

def kb_people(package_code: str):
    rows = []
    for k, v in PEOPLE.items():
        person_name = v["name"]
        if is_person_busy(k):
            label = f"üö´ {person_name} (ƒêang b·∫≠n)"
            rows.append([InlineKeyboardButton(label, callback_data="disabled")])
        else:
            label = person_name
            rows.append([InlineKeyboardButton(label, callback_data=f"people|{package_code}|{k}")])
    rows.append([InlineKeyboardButton("‚¨ÖÔ∏è Quay l·∫°i", callback_data="back|packages")])
    return InlineKeyboardMarkup(rows)

def kb_person_detail(package_code: str, person_key: str):
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üíñ Thu√™ b√© n√†y", callback_data=f"hire|{package_code}|{person_key}")],
        [InlineKeyboardButton("‚¨ÖÔ∏è Quay l·∫°i", callback_data=f"back|people|{package_code}")]
    ])

def kb_payment(package_code: str, person_key: str, tx: str):
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üì© ƒê√É X√ÅC NH·∫¨N THANH TO√ÅN", callback_data=f"userconfirm|{tx}")],
        [InlineKeyboardButton("‚¨ÖÔ∏è Quay l·∫°i", callback_data=f"back|person|{package_code}|{person_key}")]
    ])

def kb_admin_for_tx(tx: str):
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("‚úÖ Th√†nh c√¥ng", callback_data=f"admin|ok|{tx}"),
            InlineKeyboardButton("‚ùå Th·∫•t b·∫°i", callback_data=f"admin|fail|{tx}")
        ]
    ])

def format_hms(seconds: int) -> str:
    hrs, rem = divmod(seconds, 3600)
    mins, secs = divmod(rem, 60)
    if hrs:
        return f"{hrs:d}h {mins:02d}m {secs:02d}s"
    return f"{mins:d}m {secs:02d}s"

# ====== Anti-spam utilities ======
def is_user_blocked(user_id: int) -> tuple[bool, int]:
    
    rec = USER_STRIKES.get(user_id)
    if not rec:
        return False, 0
    until = rec.get("blocked_until", 0)
    if until and datetime.datetime.utcnow().timestamp() < until:
        return True, int(until - datetime.datetime.utcnow().timestamp())
    return False, 0

def record_user_action(user_id: int):
    now = datetime.datetime.utcnow().timestamp()
    arr = USER_ACTIONS.setdefault(user_id, [])
    # remove old
    cutoff = now - SPAM_WINDOW
    while arr and arr[0] < cutoff:
        arr.pop(0)
    arr.append(now)
    USER_ACTIONS[user_id] = arr
    # check violation
    if len(arr) > SPAM_MAX_ACTIONS:
        # increment strike
        rec = USER_STRIKES.setdefault(user_id, {"strikes": 0, "blocked_until": 0})
        rec["strikes"] += 1
        if rec["strikes"] >= STRIKE_LIMIT:
            rec["blocked_until"] = now + BLOCK_SECONDS
            rec["strikes"] = 0  # reset strikes after block
        USER_STRIKES[user_id] = rec
        return True, rec
    return False, USER_STRIKES.get(user_id, {"strikes": 0, "blocked_until": 0})

# ====== Countdown task ======
async def countdown_and_expire(context: ContextTypes.DEFAULT_TYPE, tx: str):
    """C·∫≠p nh·∫≠t th·ªùi gian c√≤n l·∫°i v√† thu h·ªìi khi h·∫øt"""
    session = ACTIVE_COUNTDOWNS.get(tx)
    if not session:
        return
    user_id = session["user_id"]
    msg_id = session["msg_id"]
    ends_at = session["ends_at"]  # timestamp
    contact_text = session.get("contact_text", "")
    update_interval = 15  # seconds

    while True:
        now = datetime.datetime.utcnow().timestamp()
        remaining = int(ends_at - now)
        if remaining <= 0:
            # delete message with contact if exists
            try:
                await context.bot.delete_message(chat_id=user_id, message_id=msg_id)
            except Exception:
                pass
            try:
                await context.bot.send_message(chat_id=user_id, text="‚è∞ Th·ªùi gian thu√™ ƒë√£ h·∫øt, th√¥ng tin li√™n l·∫°c ƒë√£ b·ªã thu h·ªìi. C·∫£m ∆°n b·∫°n !")
            except Exception:
                pass
            ACTIVE_COUNTDOWNS.pop(tx, None)
            return

        # edit message to show remaining
        try:
            new_text = f"{contact_text}\n\n‚è≥ Th·ªùi gian c√≤n l·∫°i: {format_hms(remaining)}"
            await context.bot.edit_message_text(chat_id=user_id, message_id=msg_id, text=new_text, parse_mode="Markdown")
        except Exception:
            # user may have deleted it; ignore
            pass

        await asyncio.sleep(update_interval)

# ====== Handlers ======
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    logger.info("User %s started bot", user.id)
    if update.message:
        try:
            await update.message.reply_photo(
                photo=MENU_PHOTO,
                caption="üå∏ *üîûMENU d·ªãch v·ª• call sexüåö* üå∏\n\nüîûüåöch·ªçn ng∆∞·ªùi n√≥i chuy·ªán ban ƒë√™m cung n√†oüåöüîû:",
                reply_markup=kb_main_menu(),
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.warning("Kh√¥ng g·ª≠i ƒë∆∞·ª£c ·∫£nh menu: %s", e)
            await update.message.reply_text("üå∏ *üîûMENU d·ªãch v·ª• call sex üîû* üå∏\n\n üîûüåöch·ªçn ng∆∞·ªùi n√≥i chuy·ªán ban ƒë√™m cung n√†oüåöüîû :", reply_markup=kb_main_menu())

async def callback_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.data:
        return

    user_id = query.from_user.id
    
    # Check for contact admin button first to bypass ban
    if query.data == "menu|contact_admin":
        await query.answer("Vui l√≤ng li√™n h·ªá Admin qua Telegram.", show_alert=True)
        await context.bot.send_message(
            chat_id=user_id,
            text=f"B·∫°n c√≥ th·ªÉ li√™n h·ªá admin t·∫°i ƒë√¢y: {ADMIN_TELEGRAM_LINK}\n\n"
                 "N·∫øu b·∫°n ƒëang b·ªã c·∫•m t·∫°m th·ªùi, vui l√≤ng ƒë·ª£i h·∫øt th·ªùi gian c·∫•m ho·∫∑c li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£."
        )
        return
        
    # Anti-spam pre-check for all other buttons
    blocked, secs_left = is_user_blocked(user_id)
    if blocked:
        await query.answer(f"B·∫°n b·ªã ch·∫∑n t·∫°m th·ªùi do spam. Th·ª≠ l·∫°i sau {secs_left}s.", show_alert=True)
        return

    # Handle disabled button click
    if query.data == "disabled":
        await query.answer("b√© n√†y hi·ªán ƒëang c√≥ kh√°ch , vui l√≤ng ch·ªçn b√© kh√°c ho·∫∑c quay l·∫°i .", show_alert=True)
        return

    await query.answer()
    
    # Record action & check violation
    violated, rec = record_user_action(user_id)
    if violated:
        # give warning or block info
        if rec.get("blocked_until", 0) and rec["blocked_until"] > datetime.datetime.utcnow().timestamp():
            await query.answer("B·∫°n ƒë√£ b·ªã ch·∫∑n t·∫°m do spam (t·ª± ƒë·ªông).", show_alert=True)
            return
        else:
            await query.answer("H√†nh ƒë·ªông qu√° nhanh ‚Äî b·∫°n ƒë√£ b·ªã c·∫£nh c√°o. Gi·∫£m t·ªëc ƒëi b·∫°n nh√©!", show_alert=True)
            # continue but warn

    data = query.data
    parts = data.split("|")
    action = parts[0]

    # MENU -> packages
    if action == "menu" and len(parts) > 1 and parts[1] == "packages":
        try:
            await query.edit_message_caption(caption=" *üîûDanh s√°ch g√≥i thu√™ theo gi·ªù üîû*:", reply_markup=kb_packages(), parse_mode="Markdown")
        except Exception:
            await query.edit_message_text(text=" *üîû Danh s√°ch g√≥i thu√™ theo gi·ªùüîû*:", reply_markup=kb_packages())

    # package selected -> show people
    elif action == "packages" and len(parts) == 2:
        pkg_code = parts[1]
        SESSIONS[query.from_user.id] = {"package": pkg_code}
        text = f"‚è≥ *B·∫°n ƒë√£ ch·ªçn g√≥i:* {PACKAGES.get(pkg_code, pkg_code)}\n\nCh·ªçn ng∆∞·ªùi b·∫°n mu·ªën thu√™:"
        try:
            await query.edit_message_caption(caption=text, reply_markup=kb_people(pkg_code), parse_mode="Markdown")
        except Exception:
            await query.edit_message_text(text=text, reply_markup=kb_people(pkg_code), parse_mode="Markdown")

    # person selected -> show photo + detail
    elif action == "people" and len(parts) == 3:
        pkg_code = parts[1]
        person_key = parts[2]
        person = PEOPLE.get(person_key)
        if not person:
            await query.edit_message_text("‚ö†Ô∏è Ng∆∞·ªùi kh√¥ng t·ªìn t·∫°i.")
            return
        SESSIONS[query.from_user.id] = {"package": pkg_code, "person": person_key}
        try:
            await query.message.delete()
        except Exception:
            pass
        caption = f"üë§ *{person['name']}*\n\n{person['desc']}\n\n‚è≥ *G√≥i:* {PACKAGES.get(pkg_code)}"
        await context.bot.send_photo(chat_id=query.from_user.id, photo=person["photo"], caption=caption,
                                     reply_markup=kb_person_detail(pkg_code, person_key), parse_mode="Markdown")

    # hire -> create tx + payment instructions
    elif action == "hire" and len(parts) == 3:
        pkg_code = parts[1]; person_key = parts[2]; user = query.from_user
        tx = gen_transaction_id()
        ORDERS[tx] = {
            "user_id": user.id,
            "username": user.username or user.full_name,
            "package": pkg_code,
            "person": person_key,
            "created_at": datetime.datetime.now().isoformat()
        }
        SESSIONS[user.id] = {"package": pkg_code, "person": person_key, "tx": tx}
        payment_msg = (
            f"üí≥ *THANH TO√ÅN*\n\n"
            f"B·∫°n ƒëang thu√™ *{PEOPLE[person_key]['name']}* ‚Äî {PACKAGES[pkg_code]}\n\n"
            f"üîë *M√£ giao d·ªãch*: `{tx}`\n\n"
            f"{PAYMENT_INFO_TEXT}\n\n"
            "‚û°Ô∏è Sau khi chuy·ªÉn ti·ªÅn, b·∫•m **üì© ƒê√É X√ÅC NH·∫¨N THANH TO√ÅN**. Admin s·∫Ω ki·ªÉm tra v√† x√°c nh·∫≠n.\n"
            "Khi admin x√°c nh·∫≠n *Th√†nh c√¥ng*, bot s·∫Ω g·ª≠i th√¥ng tin v√† b·∫Øt ƒë·∫ßu ƒë·∫øm th·ªùi gian."
        )
        try:
            await query.edit_message_text(text=payment_msg, parse_mode="Markdown", reply_markup=kb_payment(pkg_code, person_key, tx))
        except Exception:
            await context.bot.send_message(chat_id=user.id, text=payment_msg, parse_mode="Markdown", reply_markup=kb_payment(pkg_code, person_key, tx))

    # user confirms payment -> notify admins
    elif action == "userconfirm" and len(parts) == 2:
        tx = parts[1]
        order = ORDERS.get(tx)
        if not order:
            await query.answer("‚ö†Ô∏è M√£ giao d·ªãch kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a.", show_alert=True)
            return
        try:
            await query.edit_message_text("‚è≥ Vui l√≤ng ch·ªù admin ki·ªÉm tra v√† x√°c nh·∫≠n thanh to√°n. B·∫°n s·∫Ω ƒë∆∞·ª£c th√¥ng b√°o khi admin duy·ªát.")
        except Exception:
            await context.bot.send_message(chat_id=query.from_user.id, text="‚è≥ Vui l√≤ng ch·ªù admin ki·ªÉm tra v√† x√°c nh·∫≠n thanh to√°n.")
        
        # G·ª¨I TH√îNG B√ÅO T·ªöI ADMIN CH·ªà SAU KHI USER X√ÅC NH·∫¨N
        admin_notice_user_confirm = (
            f"üì¢ *ƒê∆†N H√ÄNG ƒê√É X√ÅC NH·∫¨N*\n\n"
            f"User: @{order['username']} (ID: {order['user_id']})\n"
            f"G√≥i: {PACKAGES[order['package']]}\n"
            f"Ng∆∞·ªùi: {PEOPLE[order['person']]['name']}\n"
            f"M√£ GD: `{tx}`\n"
            f"Th·ªùi gian: {order['created_at']}\n\n"
            "Ng∆∞·ªùi d√πng ƒë√£ b·∫•m n√∫t **'ƒê√É X√ÅC NH·∫¨N THANH TO√ÅN'**."
        )
        for admin_id in ADMINS:
            try:
                await context.bot.send_message(chat_id=admin_id, text=admin_notice_user_confirm, parse_mode="Markdown", reply_markup=kb_admin_for_tx(tx))
            except Exception:
                pass

    # admin confirm ok/fail -> if ok send contact + start countdown
    elif action == "admin" and len(parts) == 3:
        result = parts[1]; tx = parts[2]
        order = ORDERS.get(tx)
        if not order:
            await query.answer("‚ö†Ô∏è ƒê∆°n kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ x·ª≠ l√Ω.", show_alert=True)
            try:
                await query.edit_message_text("‚ö†Ô∏è ƒê∆°n ƒë√£ kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω.")
            except Exception:
                pass
            return
        if query.from_user.id not in ADMINS:
            await query.answer("üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán thao t√°c n√†y.", show_alert=True)
            return
        user_id = order["user_id"]; person_key = order["person"]; pkg_code = order["package"]
        
        # Th√™m tr·∫°ng th√°i v√†o order tr∆∞·ªõc khi l∆∞u v√†o l·ªãch s·ª≠
        order["status"] = "success" if result == "ok" else "failed"
        order["processed_by_admin"] = query.from_user.id
        TRANSACTION_HISTORY[tx] = order
        
        if result == "ok":
            contact_text = (
                f"üéâ *Thanh to√°n th√†nh c√¥ng!*\n\n"
                f"B·∫°n ƒë√£ thu√™ *{PEOPLE[person_key]['name']}* ‚Äî {PACKAGES[pkg_code]}\n\n"
                f"üì¨ *Th√¥ng tin li√™n l·∫°c*:\n{PEOPLE[person_key]['contact']}\n\n"
                "Ch√∫c b·∫°n c√≥ kho·∫£ng th·ªùi gian vui v·∫ª ‚ù§Ô∏è"
            )
            # send contact text and create an updating message for countdown
            try:
                sent = await context.bot.send_message(chat_id=user_id, text=contact_text, parse_mode="Markdown")
            except Exception as e:
                logger.warning("Kh√¥ng g·ª≠i ƒë∆∞·ª£c contact t·ªõi user %s: %s", user_id, e)
                sent = None
            duration = PACKAGE_SECONDS.get(pkg_code, 0)
            if sent and duration > 0:
                ends_at = datetime.datetime.utcnow().timestamp() + duration
                # store active countdown under tx
                # If user already has active session, we preserve separate tx keys.
                # Cancel existing countdown for same tx if any
                old = ACTIVE_COUNTDOWNS.get(tx)
                if old and old.get("task"):
                    try:
                        old["task"].cancel()
                    except Exception:
                        pass
                task = context.application.create_task(countdown_and_expire(context, tx))
                ACTIVE_COUNTDOWNS[tx] = {
                    "user_id": user_id,
                    "msg_id": sent.message_id,
                    "ends_at": ends_at,
                    "contact_text": contact_text,
                    "task": task,
                    "package": pkg_code,
                    "person": person_key, # Th√™m person_key v√†o ƒë√¢y ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i b·∫≠n
                }
            # update admin message
            try:
                await query.edit_message_text(f"‚úÖ ƒê√£ x√°c nh·∫≠n *Th√†nh c√¥ng* cho GD `{tx}`", parse_mode="Markdown")
            except Exception:
                pass
        else:
            # fail
            try:
                await context.bot.send_message(chat_id=user_id, text=f"‚ùå Thanh to√°n th·∫•t b·∫°i cho m√£ GD `{tx}`. Vui l√≤ng li√™n h·ªá admin ƒë·ªÉ bi·∫øt l√Ω do.")
            except Exception:
                pass
            try:
                await query.edit_message_text(f"‚ùå ƒê√£ ƒë√°nh d·∫•u *Th·∫•t b·∫°i* cho GD `{tx}`", parse_mode="Markdown")
            except Exception:
                pass
        # X√≥a kh·ªèi danh s√°ch ƒë∆°n t·∫°m
        ORDERS.pop(tx, None)

    # back handlers
    elif action == "back" and len(parts) >= 2:
        where = parts[1]
        if where == "main":
            try:
                await query.edit_message_caption(caption="üå∏ *üîûMENU d·ªãch v·ª• call sex üîû* üå∏\n\n üîûüåöch·ªçn ng∆∞·ªùi n√≥i chuy·ªán ban ƒë√™m cung n√†oüåöüîû:", reply_markup=kb_main_menu(), parse_mode="Markdown")
            except Exception:
                try:
                    await query.edit_message_text(text="üå∏ *üîûMENU d·ªãch v·ª• call sex üîû* üå∏\n\n üîûüåöch·ªçn ng∆∞·ªùi n√≥i chuy·ªán ban ƒë√™m cung n√†oüåöüîû:", reply_markup=kb_main_menu(), parse_mode="Markdown")
                except Exception:
                    await context.bot.send_photo(chat_id=query.from_user.id, photo=MENU_PHOTO, caption="üå∏ *MENU CH√çNH* üå∏\n\nCh·ªçn d·ªãch v·ª• b√™n d∆∞·ªõi:", reply_markup=kb_main_menu(), parse_mode="Markdown")
        elif where == "packages":
            try:
                await query.edit_message_caption(caption="üì¶ *üîû Danh s√°ch g√≥i thu√™ theo gi·ªùüîû*:", reply_markup=kb_packages(), parse_mode="Markdown")
            except Exception:
                await query.edit_message_text(text="üì¶ *üîû Danh s√°ch g√≥i thu√™ theo gi·ªùüîû*:", reply_markup=kb_packages(), parse_mode="Markdown")
        elif where == "people" and len(parts) == 3:
            pkg_code = parts[2]
            try:
                await query.edit_message_caption(caption=f"‚è≥ *B·∫°n ƒë√£ ch·ªçn g√≥i:* {PACKAGES.get(pkg_code)}\n\nCh·ªçn ng∆∞·ªùi b·∫°n mu·ªën thu√™:", reply_markup=kb_people(pkg_code), parse_mode="Markdown")
            except Exception:
                await query.edit_message_text(text=f"‚è≥ B·∫°n ƒë√£ ch·ªçn g√≥i: {PACKAGES.get(pkg_code)}\n\nCh·ªçn ng∆∞·ªùi b·∫°n mu·ªën thu√™:", reply_markup=kb_people(pkg_code), parse_mode="Markdown")
        elif where == "person" and len(parts) == 4:
            pkg_code = parts[2]; person_key = parts[3]
            person = PEOPLE.get(person_key)
            if person:
                caption = f"üë§ *{person['name']}*\n\n{person['desc']}\n\n‚è≥ *G√≥i:* {PACKAGES.get(pkg_code)}"
                try:
                    await query.edit_message_caption(caption=caption, reply_markup=kb_person_detail(pkg_code, person_key), parse_mode="Markdown")
                except Exception:
                    try:
                        await context.bot.send_photo(chat_id=query.from_user.id, photo=person['photo'], caption=caption, reply_markup=kb_person_detail(pkg_code, person_key), parse_mode="Markdown")
                    except Exception:
                        pass
    else:
        await query.answer()

# ====== Admin Commands & Utilities ======
async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id not in ADMINS:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn xem th·ªëng k√™.")
        return
    total_orders = len(ORDERS)
    active_sessions = len(ACTIVE_COUNTDOWNS)
    completed_transactions = len(TRANSACTION_HISTORY)
    total_users_with_sessions = len({v["user_id"] for v in ACTIVE_COUNTDOWNS.values()})
    total_known_users = len(SESSIONS)
    text = (
        f"üìä *Th·ªëng k√™ h·ªá th·ªëng*\n\n"
        f"ƒê∆°n ch·ªù x·ª≠ l√Ω (ORDERS): {total_orders}\n"
        f"Giao d·ªãch ƒë√£ ho√†n t·∫•t: {completed_transactions}\n"
        f"Phi√™n ƒëang ho·∫°t ƒë·ªông (ACTIVE_COUNTDOWNS): {active_sessions}\n"
        f"Ng∆∞·ªùi d√πng c√≥ session: {total_users_with_sessions}\n"
        f"T·ªïng ng∆∞·ªùi d√πng ƒë√£ t∆∞∆°ng t√°c (t·∫°m l∆∞u): {total_known_users}\n\n"
        f"Chi ti·∫øt Active:\n"
    )
    for tx, s in ACTIVE_COUNTDOWNS.items():
        ends_at = s.get("ends_at", 0)
        remain = int(max(0, ends_at - datetime.datetime.utcnow().timestamp()))
        text += f"- {tx} user={s.get('user_id')} remain={format_hms(remain)} pkg={s.get('package')}\n"
    await update.message.reply_text(text, parse_mode="Markdown")

async def history_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to view transaction history"""
    user = update.effective_user
    if user.id not in ADMINS:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn xem l·ªãch s·ª≠ giao d·ªãch.")
        return
    
    if not TRANSACTION_HISTORY:
        await update.message.reply_text("L·ªãch s·ª≠ giao d·ªãch tr·ªëng.")
        return
        
    text = "üìú *L·ªãch s·ª≠ giao d·ªãch ƒë√£ ho√†n t·∫•t:*\n\n"
    for tx, order in TRANSACTION_HISTORY.items():
        status_icon = "‚úÖ" if order["status"] == "success" else "‚ùå"
        text += (
            f"{status_icon} GD `{tx}`\n"
            f"  - User: @{order['username']} (ID: {order['user_id']})\n"
            f"  - G√≥i: {PACKAGES[order['package']]}\n"
            f"  - Tr·∫°ng th√°i: *{order['status'].upper()}*\n"
            f"  - Th·ªùi gian: {order['created_at'].split('T')[0]}\n\n"
        )
    await update.message.reply_text(text, parse_mode="Markdown")


async def addtime_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Usage: /addtime <tx> <minutes>  OR /addtime_user <user_id> <minutes>"""
    user = update.effective_user
    if user.id not in ADMINS:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn.")
        return
    args = context.args
    if len(args) < 2:
        await update.message.reply_text("C√∫ ph√°p: /addtime <tx> <minutes>")
        return
    tx = args[0]
    try:
        minutes = int(args[1])
    except Exception:
        await update.message.reply_text("Minutes ph·∫£i l√† s·ªë nguy√™n.")
        return
    session = ACTIVE_COUNTDOWNS.get(tx)
    if not session:
        await update.message.reply_text("Kh√¥ng t√¨m th·∫•y phi√™n ho·∫°t ƒë·ªông cho m√£ GD n√†y.")
        return
    session["ends_at"] += minutes * 60
    await update.message.reply_text(f"ƒê√£ c·ªông {minutes} ph√∫t v√†o GD {tx}. Th·ªùi gian c√≤n l·∫°i: {format_hms(int(session['ends_at']-datetime.datetime.utcnow().timestamp()))}")

async def addtime_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Usage: /addtime_user <user_id> <minutes>"""
    user = update.effective_user
    if user.id not in ADMINS:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn.")
        return
    args = context.args
    if len(args) < 2:
        await update.message.reply_text("C√∫ ph√°p: /addtime_user <user_id> <minutes>")
        return
    try:
        target = int(args[0])
        minutes = int(args[1])
    except Exception:
        await update.message.reply_text("Tham s·ªë kh√¥ng h·ª£p l·ªá.")
        return
    # t√¨m session cho user
    found = None
    for tx, s in ACTIVE_COUNTDOWNS.items():
        if s.get("user_id") == target:
            found = (tx, s); break
    if not found:
        await update.message.reply_text("Kh√¥ng t√¨m th·∫•y phi√™n ho·∫°t ƒë·ªông cho user n√†y.")
        return
    tx, s = found
    s["ends_at"] += minutes * 60
    await update.message.reply_text(f"ƒê√£ c·ªông {minutes} ph√∫t cho user {target} (GD {tx}).")

async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin broadcast: /broadcast message..."""
    user = update.effective_user
    if user.id not in ADMINS:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn.")
        return
    text = " ".join(context.args)
    if not text:
        await update.message.reply_text("C√∫ ph√°p: /broadcast <message>")
        return
    # broadcast to all users in SESSIONS keys
    targets = list(SESSIONS.keys())
    sent = 0
    for uid in targets:
        try:
            await context.bot.send_message(chat_id=uid, text=f"[Broadcast]\n\n{text}")
        except Exception:
            pass
    await update.message.reply_text(f"ƒê√£ g·ª≠i t·ªõi {sent} ng∆∞·ªùi (danh s√°ch d·ª±a tr√™n session t·∫°m).")

async def chat_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin chat to user: /chat <user_id> <message>"""
    user = update.effective_user
    if user.id not in ADMINS:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    args = context.args
    if len(args) < 2:
        await update.message.reply_text("C√∫ ph√°p: /chat <user_id> <n·ªôi dung tin nh·∫Øn>")
        return
    try:
        target_id = int(args[0])
    except ValueError:
        await update.message.reply_text("ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng s·ªë.")
        return
    message_text = " ".join(args[1:])
    try:
        await context.bot.send_message(chat_id=target_id, text=f"üí¨ *Tin nh·∫Øn t·ª´ Admin*:\n\n{message_text}", parse_mode="Markdown")
        await update.message.reply_text(f"ƒê√£ g·ª≠i tin nh·∫Øn t·ªõi ng∆∞·ªùi d√πng {target_id} th√†nh c√¥ng.")
    except Exception as e:
        await update.message.reply_text(f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn t·ªõi ng∆∞·ªùi d√πng {target_id}. L·ªói: {e}")

async def unban_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin unbans a user: /unban <user_id>"""
    user = update.effective_user
    if user.id not in ADMINS:
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    if not context.args:
        await update.message.reply_text("C√∫ ph√°p: /unban <user_id>")
        return
    try:
        target_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng s·ªë.")
        return
    if target_id in USER_STRIKES:
        del USER_STRIKES[target_id]
        await update.message.reply_text(f"ƒê√£ g·ª° c·∫•m cho ng∆∞·ªùi d√πng {target_id} th√†nh c√¥ng.")
    else:
        await update.message.reply_text(f"Ng∆∞·ªùi d√πng {target_id} kh√¥ng c√≥ trong danh s√°ch c·∫•m.")

# ====== User helper commands ======
async def mysession_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    sid = user.id
    sess = SESSIONS.get(sid)
    if not sess:
        await update.message.reply_text("B·∫°n ch∆∞a thao t√°c g√≥i n√†o.")
        return
    text = f"Phi√™n t·∫°m c·ªßa b·∫°n: {sess}"
    await update.message.reply_text(text)

# ====== Misc (help) ======
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "/start - m·ªü menu\n"
        "/help - tr·ª£ gi√∫p\n"
        "/mysession - xem session t·∫°m\n\n"
        "*(L·ªánh Admin)*\n"
        "/stats - xem th·ªëng k√™\n"
        "/history - xem l·ªãch s·ª≠ giao d·ªãch ƒë√£ ho√†n t·∫•t\n"
        "/addtime <tx> <ph√∫t> - c·ªông th√™m th·ªùi gian cho phi√™n ƒë√£ thu√™\n"
        "/chat <id_user> <tin nh·∫Øn> - nh·∫Øn tin cho ng∆∞·ªùi d√πng qua bot\n"
        "/unban <id_user> - g·ª° b·ªè c·∫•m t·∫°m th·ªùi"
    )

# ====== Main ======
def main():
    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("stats", stats_command))
    app.add_handler(CommandHandler("history", history_command)) # Th√™m l·ªánh history
    app.add_handler(CommandHandler("addtime", addtime_command))
    app.add_handler(CommandHandler("addtime_user", addtime_user_command))
    app.add_handler(CommandHandler("broadcast", broadcast_command))
    app.add_handler(CommandHandler("chat", chat_command)) # Th√™m l·ªánh chat
    app.add_handler(CommandHandler("unban", unban_command)) # Th√™m l·ªánh unban
    app.add_handler(CallbackQueryHandler(callback_router))
    logger.info("Bot ƒëang ch·∫°y...")
    app.run_polling()

if __name__ == "__main__":
    main()
